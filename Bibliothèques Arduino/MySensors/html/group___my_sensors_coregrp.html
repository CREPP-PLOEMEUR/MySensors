<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: MySensorsCore</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MySensorsCore<div class="ingroups"><a class="el" href="group__internals.html">MySensors internal APIs and functionalities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>API declaration for MySensorsCore.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for MySensorsCore:</div>
<div class="dyncontent">
<div class="center"><img src="group___my_sensors_coregrp.png" border="0" usemap="#group______my__sensors__coregrp" alt=""/></div>
<map name="group______my__sensors__coregrp" id="group______my__sensors__coregrp">
<area shape="rect" href="group___my_lockgrp.html" title="API declaration for MyNodeLock." alt="" coords="403,13,509,38"/>
<area shape="rect" href="group__internals.html" title="The interal APIs and functionalities should only be used by library developers/advanced users." alt="" coords="5,5,184,45"/>
<area shape="rect" title="API declaration for MySensorsCore." alt="" coords="232,13,355,38"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___my_lockgrp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_lockgrp.html">MyNodeLock</a></td></tr>
<tr class="memdesc:group___my_lockgrp"><td class="mdescLeft">&#160;</td><td class="mdescRight">API declaration for MyNodeLock. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontroller_config__t.html">controllerConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controller configuration.  <a href="structcontroller_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcore_config__t.html">coreConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node core configuration.  <a href="structcore_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga26981092914a185d90eab9705fba6a65"><td class="memItemLeft" align="right" valign="top"><a id="ga26981092914a185d90eab9705fba6a65"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga26981092914a185d90eab9705fba6a65">GATEWAY_ADDRESS</a>&#160;&#160;&#160;((uint8_t)0)</td></tr>
<tr class="memdesc:ga26981092914a185d90eab9705fba6a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node ID for GW sketch. <br /></td></tr>
<tr class="separator:ga26981092914a185d90eab9705fba6a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb4b846f5b2926a655d8b7f943816807"><td class="memItemLeft" align="right" valign="top"><a id="gadb4b846f5b2926a655d8b7f943816807"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gadb4b846f5b2926a655d8b7f943816807">NODE_SENSOR_ID</a>&#160;&#160;&#160;((uint8_t)255)</td></tr>
<tr class="memdesc:gadb4b846f5b2926a655d8b7f943816807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node child is always created/presented when a node is started. <br /></td></tr>
<tr class="separator:gadb4b846f5b2926a655d8b7f943816807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b6750ef8389e51a6788562c198c15d"><td class="memItemLeft" align="right" valign="top"><a id="ga00b6750ef8389e51a6788562c198c15d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga00b6750ef8389e51a6788562c198c15d">MY_CORE_VERSION</a>&#160;&#160;&#160;((uint8_t)2)</td></tr>
<tr class="memdesc:ga00b6750ef8389e51a6788562c198c15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">core version <br /></td></tr>
<tr class="separator:ga00b6750ef8389e51a6788562c198c15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a85fb213dcc4d5c60fd3c814f61843"><td class="memItemLeft" align="right" valign="top"><a id="gaf0a85fb213dcc4d5c60fd3c814f61843"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaf0a85fb213dcc4d5c60fd3c814f61843">MY_CORE_MIN_VERSION</a>&#160;&#160;&#160;((uint8_t)2)</td></tr>
<tr class="memdesc:gaf0a85fb213dcc4d5c60fd3c814f61843"><td class="mdescLeft">&#160;</td><td class="mdescRight">min core version required for compatibility <br /></td></tr>
<tr class="separator:gaf0a85fb213dcc4d5c60fd3c814f61843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ea9f42b903944bd334105b8aad9cc1e"><td class="memItemLeft" align="right" valign="top"><a id="ga1ea9f42b903944bd334105b8aad9cc1e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a>&#160;&#160;&#160;((int8_t)-1)</td></tr>
<tr class="memdesc:ga1ea9f42b903944bd334105b8aad9cc1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeping wake up by timer. <br /></td></tr>
<tr class="separator:ga1ea9f42b903944bd334105b8aad9cc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace4d44847a8947edae0fa14e487669de"><td class="memItemLeft" align="right" valign="top"><a id="gace4d44847a8947edae0fa14e487669de"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a>&#160;&#160;&#160;((int8_t)-2)</td></tr>
<tr class="memdesc:gace4d44847a8947edae0fa14e487669de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeping not possible. <br /></td></tr>
<tr class="separator:gace4d44847a8947edae0fa14e487669de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72ce069157ef0b5abbb9a6000aa9a151"><td class="memItemLeft" align="right" valign="top"><a id="ga72ce069157ef0b5abbb9a6000aa9a151"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga72ce069157ef0b5abbb9a6000aa9a151">INTERRUPT_NOT_DEFINED</a>&#160;&#160;&#160;((uint8_t)255)</td></tr>
<tr class="memdesc:ga72ce069157ef0b5abbb9a6000aa9a151"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___my_sensors_coregrp.html#gac648154f288a4f6187393e77941351b1">_sleep()</a> param: no interrupt defined <br /></td></tr>
<tr class="separator:ga72ce069157ef0b5abbb9a6000aa9a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga482f28c1ab6e002c32e3e2d018480c93"><td class="memItemLeft" align="right" valign="top"><a id="ga482f28c1ab6e002c32e3e2d018480c93"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga482f28c1ab6e002c32e3e2d018480c93">MODE_NOT_DEFINED</a>&#160;&#160;&#160;((uint8_t)255)</td></tr>
<tr class="memdesc:ga482f28c1ab6e002c32e3e2d018480c93"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___my_sensors_coregrp.html#gac648154f288a4f6187393e77941351b1">_sleep()</a> param: no mode defined <br /></td></tr>
<tr class="separator:ga482f28c1ab6e002c32e3e2d018480c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301515bc5ba79b98f3db8976bce5fe1b"><td class="memItemLeft" align="right" valign="top"><a id="ga301515bc5ba79b98f3db8976bce5fe1b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga301515bc5ba79b98f3db8976bce5fe1b">VALUE_NOT_DEFINED</a>&#160;&#160;&#160;((uint8_t)255)</td></tr>
<tr class="memdesc:ga301515bc5ba79b98f3db8976bce5fe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value not defined. <br /></td></tr>
<tr class="separator:ga301515bc5ba79b98f3db8976bce5fe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1335c81fcee8c1a07d769e31a08c2cb4"><td class="memItemLeft" align="right" valign="top"><a id="ga1335c81fcee8c1a07d769e31a08c2cb4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga1335c81fcee8c1a07d769e31a08c2cb4">FUNCTION_NOT_SUPPORTED</a>&#160;&#160;&#160;((uint16_t)0)</td></tr>
<tr class="memdesc:ga1335c81fcee8c1a07d769e31a08c2cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function not supported. <br /></td></tr>
<tr class="separator:ga1335c81fcee8c1a07d769e31a08c2cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf4aefb049900daa7097c37390962f73c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaf4aefb049900daa7097c37390962f73c">getNodeId</a> (void)</td></tr>
<tr class="separator:gaf4aefb049900daa7097c37390962f73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadddb88caf5c6cd33eeeb4a83aaacb682"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gadddb88caf5c6cd33eeeb4a83aaacb682">getParentNodeId</a> (void)</td></tr>
<tr class="separator:gadddb88caf5c6cd33eeeb4a83aaacb682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133ee0b8f0a096602001021446ec0832"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga133ee0b8f0a096602001021446ec0832">presentNode</a> (void)</td></tr>
<tr class="separator:ga133ee0b8f0a096602001021446ec0832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef20c35998db495bd4c85bac42a7ad49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaef20c35998db495bd4c85bac42a7ad49">present</a> (const uint8_t sensorId, const <a class="el" href="group___my_messagegrp.html#ga401dba5ab91a0863e553b802a33066f4">mysensors_sensor_t</a> sensorType, const char *description=&quot;&quot;, const bool requestEcho=false)</td></tr>
<tr class="separator:gaef20c35998db495bd4c85bac42a7ad49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbcf2ab02bd9bcd86e25b5b178cb9c6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gafbcf2ab02bd9bcd86e25b5b178cb9c6f">sendSketchInfo</a> (const char *name, const char *version, const bool requestEcho=false)</td></tr>
<tr class="separator:gafbcf2ab02bd9bcd86e25b5b178cb9c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d966ec420877e90d3d47a5ca5aaf51e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga2d966ec420877e90d3d47a5ca5aaf51e">send</a> (MyMessage &amp;msg, const bool requestEcho=false)</td></tr>
<tr class="separator:ga2d966ec420877e90d3d47a5ca5aaf51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9e584d8fba7802b4cca6690c3b8af80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gab9e584d8fba7802b4cca6690c3b8af80">sendBatteryLevel</a> (const uint8_t level, const bool requestEcho=false)</td></tr>
<tr class="separator:gab9e584d8fba7802b4cca6690c3b8af80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa111adec0bf3a1da6269809bf64c89a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaa111adec0bf3a1da6269809bf64c89a4">sendHeartbeat</a> (const bool requestEcho=false)</td></tr>
<tr class="separator:gaa111adec0bf3a1da6269809bf64c89a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeed465fda90453517ddeabe5ed3a0e8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaeed465fda90453517ddeabe5ed3a0e8d">sendSignalStrength</a> (const int16_t level, const bool requestEcho=false)</td></tr>
<tr class="separator:gaeed465fda90453517ddeabe5ed3a0e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484e4f95d081e39f7418dbc78cf3418b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga484e4f95d081e39f7418dbc78cf3418b">sendTXPowerLevel</a> (const uint8_t level, const bool requestEcho=false)</td></tr>
<tr class="separator:ga484e4f95d081e39f7418dbc78cf3418b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb28f2fd87b57614b89b686cf2392de2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gacb28f2fd87b57614b89b686cf2392de2">request</a> (const uint8_t childSensorId, const uint8_t variableType, const uint8_t destination=<a class="el" href="group___my_sensors_coregrp.html#ga26981092914a185d90eab9705fba6a65">GATEWAY_ADDRESS</a>)</td></tr>
<tr class="separator:gacb28f2fd87b57614b89b686cf2392de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeda8fc0af3e903a9396d73515e54700"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gabeda8fc0af3e903a9396d73515e54700">requestTime</a> (const bool requestEcho=false)</td></tr>
<tr class="separator:gabeda8fc0af3e903a9396d73515e54700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac50fdbf94f60c2d02a9c63f7d0e03852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcontroller_config__t.html">controllerConfig_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gac50fdbf94f60c2d02a9c63f7d0e03852">getControllerConfig</a> (void)</td></tr>
<tr class="separator:gac50fdbf94f60c2d02a9c63f7d0e03852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07bd2de06f11e34fca1fa77621d164ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga07bd2de06f11e34fca1fa77621d164ec">saveState</a> (const uint8_t pos, const uint8_t value)</td></tr>
<tr class="separator:ga07bd2de06f11e34fca1fa77621d164ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa2c39f578e7222854622aac43e04b11"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaaa2c39f578e7222854622aac43e04b11">loadState</a> (const uint8_t pos)</td></tr>
<tr class="separator:gaaa2c39f578e7222854622aac43e04b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6db42ef316fd88178da745993f74b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga1e6db42ef316fd88178da745993f74b6">wait</a> (const uint32_t waitingMS)</td></tr>
<tr class="separator:ga1e6db42ef316fd88178da745993f74b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd1bcea6d3d0998326e2e3e2324b491d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gacd1bcea6d3d0998326e2e3e2324b491d">wait</a> (const uint32_t waitingMS, const <a class="el" href="group___my_messagegrp.html#ga2f420202c4443624e5422b323271bf7f">mysensors_command_t</a> cmd)</td></tr>
<tr class="separator:gacd1bcea6d3d0998326e2e3e2324b491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7c117d9e3421493580e15cd6c369d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga6f7c117d9e3421493580e15cd6c369d9">wait</a> (const uint32_t waitingMS, const <a class="el" href="group___my_messagegrp.html#ga2f420202c4443624e5422b323271bf7f">mysensors_command_t</a> cmd, const uint8_t msgtype)</td></tr>
<tr class="separator:ga6f7c117d9e3421493580e15cd6c369d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd4185ec11442baa8bb2c037cbe5a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gadfd4185ec11442baa8bb2c037cbe5a5f">doYield</a> (void)</td></tr>
<tr class="separator:gadfd4185ec11442baa8bb2c037cbe5a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5f84c4227e3478af4b6600d5e8d8b15"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gab5f84c4227e3478af4b6600d5e8d8b15">sleep</a> (const uint32_t sleepingMS, const bool <a class="el" href="group___my_sensors_coregrp.html#ga4cdf6cad964561b3ab0d6058d1a4d0b5">smartSleep</a>=false)</td></tr>
<tr class="separator:gab5f84c4227e3478af4b6600d5e8d8b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57a5217aff45276f40018165d2fb10a1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga57a5217aff45276f40018165d2fb10a1">sleep</a> (const uint8_t interrupt, const uint8_t mode, const uint32_t sleepingMS=0, const bool <a class="el" href="group___my_sensors_coregrp.html#ga4cdf6cad964561b3ab0d6058d1a4d0b5">smartSleep</a>=false)</td></tr>
<tr class="separator:ga57a5217aff45276f40018165d2fb10a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dcfb8da9716960a85d4b64b8198ecbb"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga4dcfb8da9716960a85d4b64b8198ecbb">sleep</a> (const uint8_t interrupt1, const uint8_t mode1, const uint8_t interrupt2, const uint8_t mode2, const uint32_t sleepingMS=0, const bool <a class="el" href="group___my_sensors_coregrp.html#ga4cdf6cad964561b3ab0d6058d1a4d0b5">smartSleep</a>=false)</td></tr>
<tr class="separator:ga4dcfb8da9716960a85d4b64b8198ecbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d3b9fffbce15b365a7b3547761a8874"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga4d3b9fffbce15b365a7b3547761a8874">smartSleep</a> (const uint32_t sleepingMS)</td></tr>
<tr class="separator:ga4d3b9fffbce15b365a7b3547761a8874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9e11c9a491940337f7354f553391f2f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gad9e11c9a491940337f7354f553391f2f">smartSleep</a> (const uint8_t interrupt, const uint8_t mode, const uint32_t sleepingMS=0)</td></tr>
<tr class="separator:gad9e11c9a491940337f7354f553391f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cdf6cad964561b3ab0d6058d1a4d0b5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga4cdf6cad964561b3ab0d6058d1a4d0b5">smartSleep</a> (const uint8_t interrupt1, const uint8_t mode1, const uint8_t interrupt2, const uint8_t mode2, const uint32_t sleepingMS=0)</td></tr>
<tr class="separator:ga4cdf6cad964561b3ab0d6058d1a4d0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac648154f288a4f6187393e77941351b1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gac648154f288a4f6187393e77941351b1">_sleep</a> (const uint32_t sleepingMS, const bool <a class="el" href="group___my_sensors_coregrp.html#ga4cdf6cad964561b3ab0d6058d1a4d0b5">smartSleep</a>=false, const uint8_t interrupt1=<a class="el" href="group___my_sensors_coregrp.html#ga72ce069157ef0b5abbb9a6000aa9a151">INTERRUPT_NOT_DEFINED</a>, const uint8_t mode1=<a class="el" href="group___my_sensors_coregrp.html#ga482f28c1ab6e002c32e3e2d018480c93">MODE_NOT_DEFINED</a>, const uint8_t interrupt2=<a class="el" href="group___my_sensors_coregrp.html#ga72ce069157ef0b5abbb9a6000aa9a151">INTERRUPT_NOT_DEFINED</a>, const uint8_t mode2=<a class="el" href="group___my_sensors_coregrp.html#ga482f28c1ab6e002c32e3e2d018480c93">MODE_NOT_DEFINED</a>)</td></tr>
<tr class="separator:gac648154f288a4f6187393e77941351b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4428d4b0a729fc0c639eec938df7befc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga4428d4b0a729fc0c639eec938df7befc">getSleepRemaining</a> (void)</td></tr>
<tr class="separator:ga4428d4b0a729fc0c639eec938df7befc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfe68edbbd4cb4f02637004a70d3c49c"><td class="memItemLeft" align="right" valign="top"><a id="gabfe68edbbd4cb4f02637004a70d3c49c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gabfe68edbbd4cb4f02637004a70d3c49c">_begin</a> (void)</td></tr>
<tr class="memdesc:gabfe68edbbd4cb4f02637004a70d3c49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node initialisation. <br /></td></tr>
<tr class="separator:gabfe68edbbd4cb4f02637004a70d3c49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ada2249fafbab65b9ea4cbf405b3e7"><td class="memItemLeft" align="right" valign="top"><a id="ga62ada2249fafbab65b9ea4cbf405b3e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga62ada2249fafbab65b9ea4cbf405b3e7">_process</a> (void)</td></tr>
<tr class="memdesc:ga62ada2249fafbab65b9ea4cbf405b3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main framework process. <br /></td></tr>
<tr class="separator:ga62ada2249fafbab65b9ea4cbf405b3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76f320388c34d8a04613d2fbe3c6aeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gae76f320388c34d8a04613d2fbe3c6aeb">_processInternalCoreMessage</a> (void)</td></tr>
<tr class="memdesc:gae76f320388c34d8a04613d2fbe3c6aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes internal core message.  <a href="group___my_sensors_coregrp.html#gae76f320388c34d8a04613d2fbe3c6aeb">More...</a><br /></td></tr>
<tr class="separator:gae76f320388c34d8a04613d2fbe3c6aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6612f45365000acfe24c6a9d41d04e"><td class="memItemLeft" align="right" valign="top"><a id="ga8e6612f45365000acfe24c6a9d41d04e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga8e6612f45365000acfe24c6a9d41d04e">_infiniteLoop</a> (void)</td></tr>
<tr class="memdesc:ga8e6612f45365000acfe24c6a9d41d04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts node to a infinite loop if unrecoverable situation detected. <br /></td></tr>
<tr class="separator:ga8e6612f45365000acfe24c6a9d41d04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef7cfe5a0f7760dd86569d7feb69c905"><td class="memItemLeft" align="right" valign="top"><a id="gaef7cfe5a0f7760dd86569d7feb69c905"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaef7cfe5a0f7760dd86569d7feb69c905">_registerNode</a> (void)</td></tr>
<tr class="memdesc:gaef7cfe5a0f7760dd86569d7feb69c905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles registration request. <br /></td></tr>
<tr class="separator:gaef7cfe5a0f7760dd86569d7feb69c905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa00496acb5b48d9c061c9d62596d5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaafa00496acb5b48d9c061c9d62596d5d">_sendRoute</a> (MyMessage &amp;message)</td></tr>
<tr class="memdesc:gaafa00496acb5b48d9c061c9d62596d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends message according to routing table.  <a href="group___my_sensors_coregrp.html#gaafa00496acb5b48d9c061c9d62596d5d">More...</a><br /></td></tr>
<tr class="separator:gaafa00496acb5b48d9c061c9d62596d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca588d5dd5193ab8dd3dc086fd796b68"><td class="memItemLeft" align="right" valign="top"><a id="gaca588d5dd5193ab8dd3dc086fd796b68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68">receive</a> (const MyMessage &amp;) <a class="el" href="union____attribute____.html">__attribute__</a>((weak))</td></tr>
<tr class="memdesc:gaca588d5dd5193ab8dd3dc086fd796b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for incoming messages. <br /></td></tr>
<tr class="separator:gaca588d5dd5193ab8dd3dc086fd796b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1572540e1f16f13ab3f0cff023581d"><td class="memItemLeft" align="right" valign="top"><a id="gaca1572540e1f16f13ab3f0cff023581d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gaca1572540e1f16f13ab3f0cff023581d">receiveTime</a> (uint32_t) <a class="el" href="union____attribute____.html">__attribute__</a>((weak))</td></tr>
<tr class="memdesc:gaca1572540e1f16f13ab3f0cff023581d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for incoming time messages. <br /></td></tr>
<tr class="separator:gaca1572540e1f16f13ab3f0cff023581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae26b748ec6a7e8952632597d9d4f3a1f"><td class="memItemLeft" align="right" valign="top"><a id="gae26b748ec6a7e8952632597d9d4f3a1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#gae26b748ec6a7e8952632597d9d4f3a1f">presentation</a> (void) <a class="el" href="union____attribute____.html">__attribute__</a>((weak))</td></tr>
<tr class="memdesc:gae26b748ec6a7e8952632597d9d4f3a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node presentation. <br /></td></tr>
<tr class="separator:gae26b748ec6a7e8952632597d9d4f3a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d4bfa9641696bbc2c028e02e7edbe5"><td class="memItemLeft" align="right" valign="top"><a id="ga25d4bfa9641696bbc2c028e02e7edbe5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga25d4bfa9641696bbc2c028e02e7edbe5">before</a> (void) <a class="el" href="union____attribute____.html">__attribute__</a>((weak))</td></tr>
<tr class="memdesc:ga25d4bfa9641696bbc2c028e02e7edbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before node initialises. <br /></td></tr>
<tr class="separator:ga25d4bfa9641696bbc2c028e02e7edbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16badab6b5a3572c7bf7b4f6c1f3b143"><td class="memItemLeft" align="right" valign="top"><a id="ga16badab6b5a3572c7bf7b4f6c1f3b143"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga16badab6b5a3572c7bf7b4f6c1f3b143">preHwInit</a> (void) <a class="el" href="union____attribute____.html">__attribute__</a>((weak))</td></tr>
<tr class="memdesc:ga16badab6b5a3572c7bf7b4f6c1f3b143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called before any hardware initialisation is done. <br /></td></tr>
<tr class="separator:ga16badab6b5a3572c7bf7b4f6c1f3b143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6892318cbd6aa933bd2d9e70104652b1"><td class="memItemLeft" align="right" valign="top"><a id="ga6892318cbd6aa933bd2d9e70104652b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga6892318cbd6aa933bd2d9e70104652b1">setup</a> (void) <a class="el" href="union____attribute____.html">__attribute__</a>((weak))</td></tr>
<tr class="memdesc:ga6892318cbd6aa933bd2d9e70104652b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called after node initialises but before main loop. <br /></td></tr>
<tr class="separator:ga6892318cbd6aa933bd2d9e70104652b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5ade75d7d920458ea9e678a51d1884"><td class="memItemLeft" align="right" valign="top"><a id="ga1c5ade75d7d920458ea9e678a51d1884"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_sensors_coregrp.html#ga1c5ade75d7d920458ea9e678a51d1884">loop</a> (void) <a class="el" href="union____attribute____.html">__attribute__</a>((weak))</td></tr>
<tr class="memdesc:ga1c5ade75d7d920458ea9e678a51d1884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main loop. <br /></td></tr>
<tr class="separator:ga1c5ade75d7d920458ea9e678a51d1884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>API declaration for MySensorsCore. </p>
<p>MySensorsCore-related log messages, format: [!]SYSTEM:[SUB SYSTEM:]MESSAGE</p><ul>
<li>[!] Exclamation mark is prepended in case of error or warning</li>
<li>SYSTEM:<ul>
<li><b>MCO</b> messages emitted by MySensorsCore</li>
</ul>
</li>
<li>SUB SYSTEMS:<ul>
<li>MCO:<b>BGN</b> from <a class="el" href="group___my_sensors_coregrp.html#gabfe68edbbd4cb4f02637004a70d3c49c">_begin()</a></li>
<li>MCO:<b>REG</b> from <a class="el" href="group___my_sensors_coregrp.html#gaef7cfe5a0f7760dd86569d7feb69c905">_registerNode()</a></li>
<li>MCO:<b>SND</b> from <a class="el" href="group___my_sensors_coregrp.html#ga2d966ec420877e90d3d47a5ca5aaf51e">send()</a></li>
<li>MCO:<b>PIM</b> from <a class="el" href="group___my_sensors_coregrp.html#gae76f320388c34d8a04613d2fbe3c6aeb">_processInternalCoreMessage()</a></li>
<li>MCO:<b>NLK</b> from <a class="el" href="group___my_lockgrp.html#ga963a0e5128c91311eb3fbd5f89cf3a04">_nodeLock()</a></li>
</ul>
</li>
</ul>
<p>MySensorsCore debug log messages:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">E </th><th class="markdownTableHeadNone">SYS </th><th class="markdownTableHeadNone">SUB </th><th class="markdownTableHeadNone">Message </th><th class="markdownTableHeadNone">Comment  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">BGN </td><td class="markdownTableBodyNone">HW ERR </td><td class="markdownTableBodyNone">Error HW initialization (e.g. ext. EEPROM)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">BGN </td><td class="markdownTableBodyNone">INIT %s,CP=%s,FQ=%d,REL=%d,VER=%s </td><td class="markdownTableBodyNone">Core initialization, capabilities (CP), CPU frequency [Mhz] (FQ), release number (REL), library version (VER)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">BGN </td><td class="markdownTableBodyNone">BFR </td><td class="markdownTableBodyNone">Callback <a class="el" href="group___my_sensors_coregrp.html#ga25d4bfa9641696bbc2c028e02e7edbe5" title="Called before node initialises.">before()</a>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">BGN </td><td class="markdownTableBodyNone">STP </td><td class="markdownTableBodyNone">Callback <a class="el" href="group___my_sensors_coregrp.html#ga6892318cbd6aa933bd2d9e70104652b1" title="Called after node initialises but before main loop.">setup()</a>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">BGN </td><td class="markdownTableBodyNone">INIT OK,TSP=%d </td><td class="markdownTableBodyNone">Core initialised, transport status (TSP): 0=not initialised, 1=initialised, NA=not available  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">BGN </td><td class="markdownTableBodyNone">NODE UNLOCKED </td><td class="markdownTableBodyNone">Node successfully unlocked (see signing chapter)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">BGN </td><td class="markdownTableBodyNone">TSP FAIL </td><td class="markdownTableBodyNone">Transport initialization failed  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">REG </td><td class="markdownTableBodyNone">REQ </td><td class="markdownTableBodyNone">Registration request  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">REG </td><td class="markdownTableBodyNone">NOT NEEDED </td><td class="markdownTableBodyNone">No registration needed (i.e. GW)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">SND </td><td class="markdownTableBodyNone">NODE NOT REG </td><td class="markdownTableBodyNone">Node is not registered, cannot send message  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">PIM </td><td class="markdownTableBodyNone">NODE REG=%d </td><td class="markdownTableBodyNone">Registration response received, registration status (REG)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">WAI </td><td class="markdownTableBodyNone">RC=%d </td><td class="markdownTableBodyNone">Recursive call detected in <a class="el" href="group___my_sensors_coregrp.html#ga1e6db42ef316fd88178da745993f74b6">wait()</a>, level (RC)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">SLP </td><td class="markdownTableBodyNone">MS=%lu,SMS=%d,I1=%d,M1=%d,I2=%d,M2=%d </td><td class="markdownTableBodyNone">Sleep node, time (MS), smartSleep (SMS), Int1 (I1), Mode1 (M1), Int2 (I2), Mode2 (M2)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">SLP </td><td class="markdownTableBodyNone">WUP=%d </td><td class="markdownTableBodyNone">Node woke-up, reason/IRQ (WUP)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">SLP </td><td class="markdownTableBodyNone">NTL </td><td class="markdownTableBodyNone">Sleeping not possible, no time left  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">SLP </td><td class="markdownTableBodyNone">FWUPD </td><td class="markdownTableBodyNone">Sleeping not possible, FW update ongoing  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">SLP </td><td class="markdownTableBodyNone">REP </td><td class="markdownTableBodyNone">Sleeping not possible, repeater feature enabled  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">! </td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">SLP </td><td class="markdownTableBodyNone">TNR </td><td class="markdownTableBodyNone">Transport not ready, attempt to reconnect until timeout (<a class="el" href="group___sleep_setting_grp_pub.html#gae0856c1f019fa17c57ddc8cfd7a16556">MY_SLEEP_TRANSPORT_RECONNECT_TIMEOUT_MS</a>)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">NLK </td><td class="markdownTableBodyNone">NODE LOCKED. UNLOCK: GND PIN %d AND RESET </td><td class="markdownTableBodyNone">Node locked during booting, see signing chapter for additional information  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">MCO </td><td class="markdownTableBodyNone">NLK </td><td class="markdownTableBodyNone">TSL </td><td class="markdownTableBodyNone">Set transport to sleep  </td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae76f320388c34d8a04613d2fbe3c6aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae76f320388c34d8a04613d2fbe3c6aeb">&#9670;&nbsp;</a></span>_processInternalCoreMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _processInternalCoreMessage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Processes internal core message. </p>
<dl class="section return"><dt>Returns</dt><dd>True if no further processing required </dd></dl>

</div>
</div>
<a id="gaafa00496acb5b48d9c061c9d62596d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa00496acb5b48d9c061c9d62596d5d">&#9670;&nbsp;</a></span>_sendRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _sendRoute </td>
          <td>(</td>
          <td class="paramtype">MyMessage &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends message according to routing table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="gac648154f288a4f6187393e77941351b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac648154f288a4f6187393e77941351b1">&#9670;&nbsp;</a></span>_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t _sleep </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sleepingMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>smartSleep</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt1</em> = <code><a class="el" href="group___my_sensors_coregrp.html#ga72ce069157ef0b5abbb9a6000aa9a151">INTERRUPT_NOT_DEFINED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode1</em> = <code><a class="el" href="group___my_sensors_coregrp.html#ga482f28c1ab6e002c32e3e2d018480c93">MODE_NOT_DEFINED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt2</em> = <code><a class="el" href="group___my_sensors_coregrp.html#ga72ce069157ef0b5abbb9a6000aa9a151">INTERRUPT_NOT_DEFINED</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode2</em> = <code><a class="el" href="group___my_sensors_coregrp.html#ga482f28c1ab6e002c32e3e2d018480c93">MODE_NOT_DEFINED</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sleep (PowerDownMode) the MCU and radio. Wake up on timer or pin change for two separate interrupts. See: <a href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a> for details on modes and which pin is assigned to what interrupt. On Nano/Pro Mini: 0=Pin2, 1=Pin3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleepingMS</td><td>Number of milliseconds to sleep or 0 to sleep forever </td></tr>
    <tr><td class="paramname">interrupt1</td><td>(optional) First interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode1</td><td>(optional) Mode for first interrupt (RISING, FALLING, CHANGE) </td></tr>
    <tr><td class="paramname">interrupt2</td><td>(optional) Second interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode2</td><td>(optional) Mode for second interrupt (RISING, FALLING, CHANGE) </td></tr>
    <tr><td class="paramname">smartSleep</td><td>(optional) Set True if sending heartbeat and process incoming messages before going to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt number if wake up was triggered by pin change, <a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a> if wake up was triggered by timer, <a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a> if sleep was not possible (e.g. ongoing FW update) </dd></dl>

</div>
</div>
<a id="gadfd4185ec11442baa8bb2c037cbe5a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd4185ec11442baa8bb2c037cbe5a5f">&#9670;&nbsp;</a></span>doYield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void doYield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to allow scheduler to do some work. </p><dl class="section remark"><dt>Remarks</dt><dd>Internally it will call yield, kick the watchdog and update led states. </dd></dl>

</div>
</div>
<a id="gac50fdbf94f60c2d02a9c63f7d0e03852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac50fdbf94f60c2d02a9c63f7d0e03852">&#9670;&nbsp;</a></span>getControllerConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcontroller_config__t.html">controllerConfig_t</a> getControllerConfig </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the most recent node configuration received from controller </p>

</div>
</div>
<a id="gaf4aefb049900daa7097c37390962f73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4aefb049900daa7097c37390962f73c">&#9670;&nbsp;</a></span>getNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t getNodeId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return this nodes id. </p>

</div>
</div>
<a id="gadddb88caf5c6cd33eeeb4a83aaacb682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadddb88caf5c6cd33eeeb4a83aaacb682">&#9670;&nbsp;</a></span>getParentNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t getParentNodeId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the parent node id. </p>

</div>
</div>
<a id="ga4428d4b0a729fc0c639eec938df7befc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4428d4b0a729fc0c639eec938df7befc">&#9670;&nbsp;</a></span>getSleepRemaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t getSleepRemaining </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the sleep time remaining after waking up from sleep. Depending on the CPU architecture, the remaining time can be seconds off (e.g. upto roughly 8 seconds on AVR). </p><dl class="section return"><dt>Returns</dt><dd>Time remaining, in ms, when wake from sleep by an interrupt, 0 by timer (<a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a>), undefined otherwise. </dd></dl>

</div>
</div>
<a id="gaaa2c39f578e7222854622aac43e04b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa2c39f578e7222854622aac43e04b11">&#9670;&nbsp;</a></span>loadState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t loadState </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a state (from local EEPROM).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position to fetch value from (0-255) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value to store in position </dd></dl>

</div>
</div>
<a id="gaef20c35998db495bd4c85bac42a7ad49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef20c35998db495bd4c85bac42a7ad49">&#9670;&nbsp;</a></span>present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool present </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>sensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___my_messagegrp.html#ga401dba5ab91a0863e553b802a33066f4">mysensors_sensor_t</a>&#160;</td>
          <td class="paramname"><em>sensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each node must present all attached sensors before any values can be handled correctly by the controller. It is usually good to present all attached sensors after power-up in <a class="el" href="group___my_sensors_coregrp.html#ga6892318cbd6aa933bd2d9e70104652b1" title="Called after node initialises but before main loop.">setup()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sensorId</td><td>Select a unique sensor id for this sensor. Choose a number between 0-254. </td></tr>
    <tr><td class="paramname">sensorType</td><td>The sensor type. See sensor typedef in <a class="el" href="_my_message_8h.html" title="API and type declarations for MySensors messages.">MyMessage.h</a>. </td></tr>
    <tr><td class="paramname">description</td><td>A textual description of the sensor. </td></tr>
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="ga133ee0b8f0a096602001021446ec0832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133ee0b8f0a096602001021446ec0832">&#9670;&nbsp;</a></span>presentNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void presentNode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends node information to the gateway. </p>

</div>
</div>
<a id="gacb28f2fd87b57614b89b686cf2392de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb28f2fd87b57614b89b686cf2392de2">&#9670;&nbsp;</a></span>request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool request </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>childSensorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>variableType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>destination</em> = <code><a class="el" href="group___my_sensors_coregrp.html#ga26981092914a185d90eab9705fba6a65">GATEWAY_ADDRESS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests a value from gateway or some other sensor in the radio network. Make sure to add callback-method in begin-method to handle request responses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">childSensorId</td><td>The unique child id for the different sensors connected to this Arduino. 0-254. </td></tr>
    <tr><td class="paramname">variableType</td><td>The variableType to fetch </td></tr>
    <tr><td class="paramname">destination</td><td>The nodeId of other node in radio network. Default is gateway </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="gabeda8fc0af3e903a9396d73515e54700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeda8fc0af3e903a9396d73515e54700">&#9670;&nbsp;</a></span>requestTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool requestTime </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests time from controller. Answer will be delivered to receiveTime function in sketch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="ga07bd2de06f11e34fca1fa77621d164ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07bd2de06f11e34fca1fa77621d164ec">&#9670;&nbsp;</a></span>saveState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void saveState </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save a state (in local EEPROM). Good for actuators to "remember" state between power cycles.</p>
<p>You have 256 bytes to play with. Note that there is a limitation on the number of writes the EEPROM can handle (~100 000 cycles on ATMega328).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position to store value in (0-255) </td></tr>
    <tr><td class="paramname">value</td><td>to store in position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2d966ec420877e90d3d47a5ca5aaf51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d966ec420877e90d3d47a5ca5aaf51e">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool send </td>
          <td>(</td>
          <td class="paramtype">MyMessage &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a message to gateway or one of the other nodes in the radio network </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>Message to send </td></tr>
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="gab9e584d8fba7802b4cca6690c3b8af80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e584d8fba7802b4cca6690c3b8af80">&#9670;&nbsp;</a></span>sendBatteryLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendBatteryLevel </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send this nodes battery level to gateway. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Level between 0-100(%) </td></tr>
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="gaa111adec0bf3a1da6269809bf64c89a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa111adec0bf3a1da6269809bf64c89a4">&#9670;&nbsp;</a></span>sendHeartbeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendHeartbeat </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a heartbeat message (I'm alive!) to the gateway/controller. The payload will be an incremental 16 bit integer value starting at 1 when sensor is powered on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="gaeed465fda90453517ddeabe5ed3a0e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeed465fda90453517ddeabe5ed3a0e8d">&#9670;&nbsp;</a></span>sendSignalStrength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendSignalStrength </td>
          <td>(</td>
          <td class="paramtype">const int16_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send this nodes signal strength to gateway. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Signal strength can be RSSI if the radio provide it, or another kind of calculation </td></tr>
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="gafbcf2ab02bd9bcd86e25b5b178cb9c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbcf2ab02bd9bcd86e25b5b178cb9c6f">&#9670;&nbsp;</a></span>sendSketchInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendSketchInfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends sketch meta information to the gateway. Not mandatory but a nice thing to do. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String containing a short Sketch name or NULL if not applicable </td></tr>
    <tr><td class="paramname">version</td><td>String containing a short Sketch version or NULL if not applicable </td></tr>
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="ga484e4f95d081e39f7418dbc78cf3418b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484e4f95d081e39f7418dbc78cf3418b">&#9670;&nbsp;</a></span>sendTXPowerLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sendTXPowerLevel </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>requestEcho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send this nodes TX power level to gateway. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>For instance, can be TX power level in dbm </td></tr>
    <tr><td class="paramname">requestEcho</td><td>Set this to true if you want destination node to echo the message back to this node. Default is not to request echo. If set to true, the final destination will echo back the contents of the message, triggering the <a class="el" href="group___my_sensors_coregrp.html#gaca588d5dd5193ab8dd3dc086fd796b68" title="Callback for incoming messages.">receive()</a> function on the original node with a copy of the message, with message.isEcho() set to true and sender/destination switched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Returns true if message reached the first stop on its way to destination. </dd></dl>

</div>
</div>
<a id="gab5f84c4227e3478af4b6600d5e8d8b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5f84c4227e3478af4b6600d5e8d8b15">&#9670;&nbsp;</a></span>sleep() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t sleep </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sleepingMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>smartSleep</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sleep (PowerDownMode) the MCU and radio. Wake up on timer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleepingMS</td><td>Number of milliseconds to sleep. </td></tr>
    <tr><td class="paramname">smartSleep</td><td>Set True if sending heartbeat and process incoming messages before going to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a> if timer woke it up, <a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a> if not possible (e.g. ongoing FW update) </dd></dl>

</div>
</div>
<a id="ga57a5217aff45276f40018165d2fb10a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57a5217aff45276f40018165d2fb10a1">&#9670;&nbsp;</a></span>sleep() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t sleep </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sleepingMS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>smartSleep</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sleep (PowerDownMode) the MCU and radio. Wake up on timer or pin change. See: <a href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a> for details on modes and which pin is assigned to what interrupt. On Nano/Pro Mini: 0=Pin2, 1=Pin3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt</td><td>Interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode</td><td>RISING, FALLING, CHANGE </td></tr>
    <tr><td class="paramname">sleepingMS</td><td>Number of milliseconds to sleep or 0 to sleep forever </td></tr>
    <tr><td class="paramname">smartSleep</td><td>Set True if sending heartbeat and process incoming messages before going to sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt number if wake up was triggered by pin change, <a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a> if wake up was triggered by timer, <a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a> if sleep was not possible (e.g. ongoing FW update) </dd></dl>

</div>
</div>
<a id="ga4dcfb8da9716960a85d4b64b8198ecbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dcfb8da9716960a85d4b64b8198ecbb">&#9670;&nbsp;</a></span>sleep() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t sleep </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sleepingMS</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>smartSleep</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sleep (PowerDownMode) the MCU and radio. Wake up on timer or pin change for two separate interrupts. See: <a href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a> for details on modes and which pin is assigned to what interrupt. On Nano/Pro Mini: 0=Pin2, 1=Pin3 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt1</td><td>First interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode1</td><td>Mode for first interrupt (RISING, FALLING, CHANGE) </td></tr>
    <tr><td class="paramname">interrupt2</td><td>Second interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode2</td><td>Mode for second interrupt (RISING, FALLING, CHANGE) </td></tr>
    <tr><td class="paramname">sleepingMS</td><td>Number of milliseconds to sleep or 0 to sleep forever </td></tr>
    <tr><td class="paramname">smartSleep</td><td>Set True if sending heartbeat and process incoming messages before going to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt number if wake up was triggered by pin change, <a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a> if wake up was triggered by timer, <a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a> if sleep was not possible (e.g. ongoing FW update) </dd></dl>

</div>
</div>
<a id="ga4d3b9fffbce15b365a7b3547761a8874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d3b9fffbce15b365a7b3547761a8874">&#9670;&nbsp;</a></span>smartSleep() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t smartSleep </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sleepingMS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use sleep(ms, true) instead Same as <a class="el" href="group___my_sensors_coregrp.html#gab5f84c4227e3478af4b6600d5e8d8b15">sleep()</a>, send heartbeat and process incoming messages before going to sleep. Specify the time to wait for incoming messages by defining <a class="el" href="group___sleep_setting_grp_pub.html#gaf353bf3627ebd8f15e200b320e2e065d">MY_SMART_SLEEP_WAIT_DURATION_MS</a> to a time (ms). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sleepingMS</td><td>Number of milliseconds to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a> if timer woke it up, <a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a> if not possible (e.g. ongoing FW update) </dd></dl>

</div>
</div>
<a id="gad9e11c9a491940337f7354f553391f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9e11c9a491940337f7354f553391f2f">&#9670;&nbsp;</a></span>smartSleep() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t smartSleep </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sleepingMS</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000021">Deprecated:</a></b></dt><dd>Use sleep(interrupt, mode, ms, true) instead Same as <a class="el" href="group___my_sensors_coregrp.html#gab5f84c4227e3478af4b6600d5e8d8b15">sleep()</a>, send heartbeat and process incoming messages before going to sleep. Specify the time to wait for incoming messages by defining <a class="el" href="group___sleep_setting_grp_pub.html#gaf353bf3627ebd8f15e200b320e2e065d">MY_SMART_SLEEP_WAIT_DURATION_MS</a> to a time (ms). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt</td><td>Interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode</td><td>RISING, FALLING, CHANGE </td></tr>
    <tr><td class="paramname">sleepingMS</td><td>Number of milliseconds to sleep or 0 to sleep forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt number if wake up was triggered by pin change, <a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a> if wake up was triggered by timer, <a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a> if sleep was not possible (e.g. ongoing FW update) </dd></dl>

</div>
</div>
<a id="ga4cdf6cad964561b3ab0d6058d1a4d0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cdf6cad964561b3ab0d6058d1a4d0b5">&#9670;&nbsp;</a></span>smartSleep() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t smartSleep </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>interrupt2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>mode2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>sleepingMS</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000022">Deprecated:</a></b></dt><dd>Use sleep(interrupt1, mode1, interrupt2, mode2, ms, true) instead Same as <a class="el" href="group___my_sensors_coregrp.html#gab5f84c4227e3478af4b6600d5e8d8b15">sleep()</a>, send heartbeat and process incoming messages before going to sleep. Specify the time to wait for incoming messages by defining <a class="el" href="group___sleep_setting_grp_pub.html#gaf353bf3627ebd8f15e200b320e2e065d">MY_SMART_SLEEP_WAIT_DURATION_MS</a> to a time (ms). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interrupt1</td><td>First interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode1</td><td>Mode for first interrupt (RISING, FALLING, CHANGE) </td></tr>
    <tr><td class="paramname">interrupt2</td><td>Second interrupt that should trigger the wakeup </td></tr>
    <tr><td class="paramname">mode2</td><td>Mode for second interrupt (RISING, FALLING, CHANGE) </td></tr>
    <tr><td class="paramname">sleepingMS</td><td>Number of milliseconds to sleep or 0 to sleep forever </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt number if wake up was triggered by pin change, <a class="el" href="group___my_sensors_coregrp.html#ga1ea9f42b903944bd334105b8aad9cc1e">MY_WAKE_UP_BY_TIMER</a> if wake up was triggered by timer, <a class="el" href="group___my_sensors_coregrp.html#gace4d44847a8947edae0fa14e487669de">MY_SLEEP_NOT_POSSIBLE</a> if sleep was not possible (e.g. ongoing FW update) </dd></dl>

</div>
</div>
<a id="ga1e6db42ef316fd88178da745993f74b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6db42ef316fd88178da745993f74b6">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>waitingMS</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a specified amount of time to pass. Keeps process()ing. This does not power-down the radio nor the Arduino. Because this calls process() in a loop, it is a good way to wait in your <a class="el" href="group___my_sensors_coregrp.html#ga1c5ade75d7d920458ea9e678a51d1884" title="Main loop.">loop()</a> on a repeater node or sensor that listens to messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitingMS</td><td>Number of milliseconds to wait. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd1bcea6d3d0998326e2e3e2324b491d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd1bcea6d3d0998326e2e3e2324b491d">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>waitingMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___my_messagegrp.html#ga2f420202c4443624e5422b323271bf7f">mysensors_command_t</a>&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a specified amount of time to pass or until specified message received. Keeps process()ing. This does not power-down the radio nor the Arduino. Because this calls process() in a loop, it is a good way to wait in your <a class="el" href="group___my_sensors_coregrp.html#ga1c5ade75d7d920458ea9e678a51d1884" title="Main loop.">loop()</a> on a repeater node or sensor that listens to messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitingMS</td><td>Number of milliseconds to wait. </td></tr>
    <tr><td class="paramname">cmd</td><td>Command of incoming message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if specified message received </dd></dl>

</div>
</div>
<a id="ga6f7c117d9e3421493580e15cd6c369d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7c117d9e3421493580e15cd6c369d9">&#9670;&nbsp;</a></span>wait() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>waitingMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___my_messagegrp.html#ga2f420202c4443624e5422b323271bf7f">mysensors_command_t</a>&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>msgtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wait for a specified amount of time to pass or until specified message received. Keeps process()ing. This does not power-down the radio nor the Arduino. Because this calls process() in a loop, it is a good way to wait in your <a class="el" href="group___my_sensors_coregrp.html#ga1c5ade75d7d920458ea9e678a51d1884" title="Main loop.">loop()</a> on a repeater node or sensor that listens to messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitingMS</td><td>Number of milliseconds to wait. </td></tr>
    <tr><td class="paramname">cmd</td><td>Command of incoming message. </td></tr>
    <tr><td class="paramname">msgtype</td><td>Message type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if specified message received </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
