<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SPIFlash Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_s_p_i_flash-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SPIFlash Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_s_p_i_flash_8h_source.html">SPIFlash.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac5073784eec99c86677a1f0a7c9ba302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#ac5073784eec99c86677a1f0a7c9ba302">SPIFlash</a> (uint8_t slaveSelectPin, uint16_t jedecID=0)</td></tr>
<tr class="memdesc:ac5073784eec99c86677a1f0a7c9ba302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_s_p_i_flash.html#ac5073784eec99c86677a1f0a7c9ba302">More...</a><br /></td></tr>
<tr class="separator:ac5073784eec99c86677a1f0a7c9ba302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bbeabafcf5ff94bfa38ccdd2e729cd"><td class="memItemLeft" align="right" valign="top"><a id="a16bbeabafcf5ff94bfa38ccdd2e729cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a16bbeabafcf5ff94bfa38ccdd2e729cd">initialize</a> ()</td></tr>
<tr class="memdesc:a16bbeabafcf5ff94bfa38ccdd2e729cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">setup SPI, read device ID etc... <br /></td></tr>
<tr class="separator:a16bbeabafcf5ff94bfa38ccdd2e729cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b179ac40b6e5d0a2e061df5aa83c08"><td class="memItemLeft" align="right" valign="top"><a id="a09b179ac40b6e5d0a2e061df5aa83c08"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a09b179ac40b6e5d0a2e061df5aa83c08">command</a> (uint8_t cmd, bool isWrite=false)</td></tr>
<tr class="memdesc:a09b179ac40b6e5d0a2e061df5aa83c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a command to the flash chip, pass TRUE for isWrite when its a write command. <br /></td></tr>
<tr class="separator:a09b179ac40b6e5d0a2e061df5aa83c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae340e85102a26b2cf2ea1ba1f1ef2a44"><td class="memItemLeft" align="right" valign="top"><a id="ae340e85102a26b2cf2ea1ba1f1ef2a44"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#ae340e85102a26b2cf2ea1ba1f1ef2a44">readStatus</a> ()</td></tr>
<tr class="memdesc:ae340e85102a26b2cf2ea1ba1f1ef2a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the STATUS register <br /></td></tr>
<tr class="separator:ae340e85102a26b2cf2ea1ba1f1ef2a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43af0a6ae881d4af97b7680b24c22e"><td class="memItemLeft" align="right" valign="top"><a id="a7c43af0a6ae881d4af97b7680b24c22e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a7c43af0a6ae881d4af97b7680b24c22e">readByte</a> (uint32_t addr)</td></tr>
<tr class="memdesc:a7c43af0a6ae881d4af97b7680b24c22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">read 1 byte from flash memory <br /></td></tr>
<tr class="separator:a7c43af0a6ae881d4af97b7680b24c22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25010ef2288eed50aac0d6545f33b35a"><td class="memItemLeft" align="right" valign="top"><a id="a25010ef2288eed50aac0d6545f33b35a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a25010ef2288eed50aac0d6545f33b35a">readBytes</a> (uint32_t addr, void *buf, uint16_t len)</td></tr>
<tr class="memdesc:a25010ef2288eed50aac0d6545f33b35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">read unlimited # of bytes <br /></td></tr>
<tr class="separator:a25010ef2288eed50aac0d6545f33b35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc86d388215c463f2f67eb105e18b610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#adc86d388215c463f2f67eb105e18b610">writeByte</a> (uint32_t addr, uint8_t byt)</td></tr>
<tr class="memdesc:adc86d388215c463f2f67eb105e18b610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write 1 byte to flash memory.  <a href="class_s_p_i_flash.html#adc86d388215c463f2f67eb105e18b610">More...</a><br /></td></tr>
<tr class="separator:adc86d388215c463f2f67eb105e18b610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d4da01bf219240c8b5e95441b7efd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a83d4da01bf219240c8b5e95441b7efd5">writeBytes</a> (uint32_t addr, const void *buf, uint16_t len)</td></tr>
<tr class="memdesc:a83d4da01bf219240c8b5e95441b7efd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">write multiple bytes to flash memory (up to 64K), if define SPIFLASH_SST25TYPE is set AAI Word Programming will be used  <a href="class_s_p_i_flash.html#a83d4da01bf219240c8b5e95441b7efd5">More...</a><br /></td></tr>
<tr class="separator:a83d4da01bf219240c8b5e95441b7efd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71ff5fe5e77f31f22d87617a1137c08"><td class="memItemLeft" align="right" valign="top"><a id="ad71ff5fe5e77f31f22d87617a1137c08"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#ad71ff5fe5e77f31f22d87617a1137c08">busy</a> ()</td></tr>
<tr class="memdesc:ad71ff5fe5e77f31f22d87617a1137c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the chip is busy erasing/writing <br /></td></tr>
<tr class="separator:ad71ff5fe5e77f31f22d87617a1137c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6dcd26e61621f1a4c006e1bfd4ec1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#aff6dcd26e61621f1a4c006e1bfd4ec1e">chipErase</a> ()</td></tr>
<tr class="memdesc:aff6dcd26e61621f1a4c006e1bfd4ec1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase entire flash memory array  <a href="class_s_p_i_flash.html#aff6dcd26e61621f1a4c006e1bfd4ec1e">More...</a><br /></td></tr>
<tr class="separator:aff6dcd26e61621f1a4c006e1bfd4ec1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6617e57e4438dacac2bbfc2d9319f3f"><td class="memItemLeft" align="right" valign="top"><a id="af6617e57e4438dacac2bbfc2d9319f3f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#af6617e57e4438dacac2bbfc2d9319f3f">blockErase4K</a> (uint32_t address)</td></tr>
<tr class="memdesc:af6617e57e4438dacac2bbfc2d9319f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a 4Kbyte block <br /></td></tr>
<tr class="separator:af6617e57e4438dacac2bbfc2d9319f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7091ac260a04c350e8e04c1ac9366223"><td class="memItemLeft" align="right" valign="top"><a id="a7091ac260a04c350e8e04c1ac9366223"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a7091ac260a04c350e8e04c1ac9366223">blockErase32K</a> (uint32_t address)</td></tr>
<tr class="memdesc:a7091ac260a04c350e8e04c1ac9366223"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a 32Kbyte block <br /></td></tr>
<tr class="separator:a7091ac260a04c350e8e04c1ac9366223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940fe8bdb28d42473ae6c010aaadc7cb"><td class="memItemLeft" align="right" valign="top"><a id="a940fe8bdb28d42473ae6c010aaadc7cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a940fe8bdb28d42473ae6c010aaadc7cb">blockErase64K</a> (uint32_t addr)</td></tr>
<tr class="memdesc:a940fe8bdb28d42473ae6c010aaadc7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">erase a 64Kbyte block <br /></td></tr>
<tr class="separator:a940fe8bdb28d42473ae6c010aaadc7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd8f7a6c7924dcd937854fd8bc39372"><td class="memItemLeft" align="right" valign="top"><a id="a3cd8f7a6c7924dcd937854fd8bc39372"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a3cd8f7a6c7924dcd937854fd8bc39372">readDeviceId</a> ()</td></tr>
<tr class="memdesc:a3cd8f7a6c7924dcd937854fd8bc39372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the manufacturer and device ID bytes (as a short word) <br /></td></tr>
<tr class="separator:a3cd8f7a6c7924dcd937854fd8bc39372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bec0b9454a3ad6c9f34b956565de35"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a24bec0b9454a3ad6c9f34b956565de35">readUniqueId</a> ()</td></tr>
<tr class="memdesc:a24bec0b9454a3ad6c9f34b956565de35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the 64 bit unique identifier, stores it in <a class="el" href="class_s_p_i_flash.html#a2da8418983e105c07d370f8d1e266db5">UNIQUEID</a>[8].  <a href="class_s_p_i_flash.html#a24bec0b9454a3ad6c9f34b956565de35">More...</a><br /></td></tr>
<tr class="separator:a24bec0b9454a3ad6c9f34b956565de35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db6879cde04b58bb9288c7a1686511d"><td class="memItemLeft" align="right" valign="top"><a id="a8db6879cde04b58bb9288c7a1686511d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a8db6879cde04b58bb9288c7a1686511d">sleep</a> ()</td></tr>
<tr class="memdesc:a8db6879cde04b58bb9288c7a1686511d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put device to sleep. <br /></td></tr>
<tr class="separator:a8db6879cde04b58bb9288c7a1686511d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d129f6173d4c3e9e8ffee80862c050"><td class="memItemLeft" align="right" valign="top"><a id="a05d129f6173d4c3e9e8ffee80862c050"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a05d129f6173d4c3e9e8ffee80862c050">wakeup</a> ()</td></tr>
<tr class="memdesc:a05d129f6173d4c3e9e8ffee80862c050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wake device. <br /></td></tr>
<tr class="separator:a05d129f6173d4c3e9e8ffee80862c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17149e4a835777501c3b4d35952e6c34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a17149e4a835777501c3b4d35952e6c34">end</a> ()</td></tr>
<tr class="memdesc:a17149e4a835777501c3b4d35952e6c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">end  <a href="class_s_p_i_flash.html#a17149e4a835777501c3b4d35952e6c34">More...</a><br /></td></tr>
<tr class="separator:a17149e4a835777501c3b4d35952e6c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2da8418983e105c07d370f8d1e266db5"><td class="memItemLeft" align="right" valign="top"><a id="a2da8418983e105c07d370f8d1e266db5"></a>
static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a2da8418983e105c07d370f8d1e266db5">UNIQUEID</a> [8]</td></tr>
<tr class="memdesc:a2da8418983e105c07d370f8d1e266db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage for unique identifier. <br /></td></tr>
<tr class="separator:a2da8418983e105c07d370f8d1e266db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5af4bdf812b244cd5b3588bb64cd0aa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a5af4bdf812b244cd5b3588bb64cd0aa4">select</a> ()</td></tr>
<tr class="memdesc:a5af4bdf812b244cd5b3588bb64cd0aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">select  <a href="class_s_p_i_flash.html#a5af4bdf812b244cd5b3588bb64cd0aa4">More...</a><br /></td></tr>
<tr class="separator:a5af4bdf812b244cd5b3588bb64cd0aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67b2506d40b113b2f2185f6a1c7dbfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#af67b2506d40b113b2f2185f6a1c7dbfd">unselect</a> ()</td></tr>
<tr class="memdesc:af67b2506d40b113b2f2185f6a1c7dbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">unselect  <a href="class_s_p_i_flash.html#af67b2506d40b113b2f2185f6a1c7dbfd">More...</a><br /></td></tr>
<tr class="separator:af67b2506d40b113b2f2185f6a1c7dbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9d92074cf6c168dc177606c29a3818e2"><td class="memItemLeft" align="right" valign="top"><a id="a9d92074cf6c168dc177606c29a3818e2"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a9d92074cf6c168dc177606c29a3818e2">_slaveSelectPin</a></td></tr>
<tr class="memdesc:a9d92074cf6c168dc177606c29a3818e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave select pin. <br /></td></tr>
<tr class="separator:a9d92074cf6c168dc177606c29a3818e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c99489c294d6d5adeb65ef880cd229b"><td class="memItemLeft" align="right" valign="top"><a id="a5c99489c294d6d5adeb65ef880cd229b"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#a5c99489c294d6d5adeb65ef880cd229b">_jedecID</a></td></tr>
<tr class="memdesc:a5c99489c294d6d5adeb65ef880cd229b"><td class="mdescLeft">&#160;</td><td class="mdescRight">JEDEC ID. <br /></td></tr>
<tr class="separator:a5c99489c294d6d5adeb65ef880cd229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2c920e973c5b58ba70dd1f565aa096"><td class="memItemLeft" align="right" valign="top"><a id="adc2c920e973c5b58ba70dd1f565aa096"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#adc2c920e973c5b58ba70dd1f565aa096">_SPCR</a></td></tr>
<tr class="memdesc:adc2c920e973c5b58ba70dd1f565aa096"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPCR. <br /></td></tr>
<tr class="separator:adc2c920e973c5b58ba70dd1f565aa096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26a883c4c2802308818047130e248c8"><td class="memItemLeft" align="right" valign="top"><a id="ab26a883c4c2802308818047130e248c8"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_p_i_flash.html#ab26a883c4c2802308818047130e248c8">_SPSR</a></td></tr>
<tr class="memdesc:ab26a883c4c2802308818047130e248c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPSR. <br /></td></tr>
<tr class="separator:ab26a883c4c2802308818047130e248c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_s_p_i_flash.html">SPIFlash</a> class </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac5073784eec99c86677a1f0a7c9ba302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5073784eec99c86677a1f0a7c9ba302">&#9670;&nbsp;</a></span>SPIFlash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SPIFlash::SPIFlash </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveSelectPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>jedecID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>IMPORTANT: NAND FLASH memory requires erase before write, because it can only transition from 1s to 0s and only the erase command can reset all 0s to 1s See <a href="http://en.wikipedia.org/wiki/Flash_memory">http://en.wikipedia.org/wiki/Flash_memory</a> The smallest range that can be erased is a sector (4K, 32K, 64K); there is also a chip erase command Constructor. JedecID is optional but recommended, since this will ensure that the device is present and has a valid response get this from the datasheet of your flash chip Example for Atmel-Adesto 4Mbit AT25DF041A: 0x1F44 (page 27: <a href="http://www.adestotech.com/sites/default/files/datasheets/doc3668.pdf">http://www.adestotech.com/sites/default/files/datasheets/doc3668.pdf</a>) Example for Winbond 4Mbit W25X40CL: 0xEF30 (page 14: <a href="http://www.winbond.com/NR/rdonlyres/6E25084C-0BFE-4B25-903D-AE10221A0929/0/W25X40CL.pdf">http://www.winbond.com/NR/rdonlyres/6E25084C-0BFE-4B25-903D-AE10221A0929/0/W25X40CL.pdf</a>) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff6dcd26e61621f1a4c006e1bfd4ec1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6dcd26e61621f1a4c006e1bfd4ec1e">&#9670;&nbsp;</a></span>chipErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPIFlash::chipErase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>erase entire flash memory array </p>
<p>erase entire flash memory array may take several seconds depending on size, but is non blocking so you may wait for this to complete using <a class="el" href="class_s_p_i_flash.html#ad71ff5fe5e77f31f22d87617a1137c08" title="check if the chip is busy erasing/writing">busy()</a> or continue doing other things and later check if the chip is done with <a class="el" href="class_s_p_i_flash.html#ad71ff5fe5e77f31f22d87617a1137c08" title="check if the chip is busy erasing/writing">busy()</a> note that any command will first wait for chip to become available using <a class="el" href="class_s_p_i_flash.html#ad71ff5fe5e77f31f22d87617a1137c08" title="check if the chip is busy erasing/writing">busy()</a> so no need to do that twice </p>

</div>
</div>
<a id="a17149e4a835777501c3b4d35952e6c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17149e4a835777501c3b4d35952e6c34">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPIFlash::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>end </p>
<p>cleanup </p>

</div>
</div>
<a id="a24bec0b9454a3ad6c9f34b956565de35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bec0b9454a3ad6c9f34b956565de35">&#9670;&nbsp;</a></span>readUniqueId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t * SPIFlash::readUniqueId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the 64 bit unique identifier, stores it in <a class="el" href="class_s_p_i_flash.html#a2da8418983e105c07d370f8d1e266db5">UNIQUEID</a>[8]. </p>
<p>Get the 64 bit unique identifier, stores it in UNIQUEID[8]. Only needs to be called once, ie after initialize Returns the byte pointer to the UNIQUEID byte array Read UNIQUEID like this: flash.readUniqueId(); for (uint8_t i=0;i&lt;8;i++) { Serial.print(flash.UNIQUEID[i], HEX); Serial.print(' '); } or like this: flash.readUniqueId(); uint8_t* MAC = flash.readUniqueId(); for (uint8_t i=0;i&lt;8;i++) { Serial.print(MAC[i], HEX); Serial.print(' '); } </p>

</div>
</div>
<a id="a5af4bdf812b244cd5b3588bb64cd0aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af4bdf812b244cd5b3588bb64cd0aa4">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SPIFlash::select </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>select </p>
<p>Select the flash chip. </p>

</div>
</div>
<a id="af67b2506d40b113b2f2185f6a1c7dbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67b2506d40b113b2f2185f6a1c7dbfd">&#9670;&nbsp;</a></span>unselect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SPIFlash::unselect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unselect </p>
<p>UNselect the flash chip. </p>

</div>
</div>
<a id="adc86d388215c463f2f67eb105e18b610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc86d388215c463f2f67eb105e18b610">&#9670;&nbsp;</a></span>writeByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPIFlash::writeByte </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write 1 byte to flash memory. </p>
<p>Write 1 byte to flash memory WARNING: you can only write to previously erased memory locations (see datasheet) use the block erase commands to first clear memory (write 0xFFs) </p>

</div>
</div>
<a id="a83d4da01bf219240c8b5e95441b7efd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d4da01bf219240c8b5e95441b7efd5">&#9670;&nbsp;</a></span>writeBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SPIFlash::writeBytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write multiple bytes to flash memory (up to 64K), if define SPIFLASH_SST25TYPE is set AAI Word Programming will be used </p>
<p>write multiple bytes to flash memory (up to 64K) WARNING: you can only write to previously erased memory locations (see datasheet) use the block erase commands to first clear memory (write 0xFFs) This version handles both page alignment and data blocks larger than 256 bytes. See documentation of #MY_SPIFLASH_SST25TYPE define for more information </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>drivers/SPIFlash/<a class="el" href="_s_p_i_flash_8h_source.html">SPIFlash.h</a></li>
<li>drivers/SPIFlash/SPIFlash.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
