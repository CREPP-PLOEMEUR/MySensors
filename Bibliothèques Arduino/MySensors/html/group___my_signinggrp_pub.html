<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Message signing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">Message signing<div class="ingroups"><a class="el" href="group__publics.html">MySensors public APIs and functionalities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The message signing infrastructure provides message authenticity to users by signing MySensors messages.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Message signing:</div>
<div class="dyncontent">
<div class="center"><img src="group___my_signinggrp_pub.png" border="0" usemap="#group______my__signinggrp__pub" alt=""/></div>
<map name="group______my__signinggrp__pub" id="group______my__signinggrp__pub">
<area shape="rect" href="group__publics.html" title="The public APIs and functionalities are directly accessible to sketch developers/users." alt="" coords="5,35,173,75"/>
<area shape="rect" title="The message signing infrastructure provides message authenticity to users by signing MySensors messag..." alt="" coords="221,42,352,67"/>
<area shape="rect" href="group___my_signing_debug_messages.html" title="Explanation of the abstract signing related debug messages." alt="" coords="406,5,570,45"/>
<area shape="rect" href="group___my_signing_troubleshootinggrp.html" title="Typical signing related failure cases and how to solve them." alt="" coords="400,70,576,95"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___my_signing_debug_messages"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_signing_debug_messages.html">Signing related debug messages</a></td></tr>
<tr class="memdesc:group___my_signing_debug_messages"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explanation of the abstract signing related debug messages. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___my_signing_troubleshootinggrp"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___my_signing_troubleshootinggrp.html">Signing troubleshooting</a></td></tr>
<tr class="memdesc:group___my_signing_troubleshootinggrp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typical signing related failure cases and how to solve them. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The message signing infrastructure provides message authenticity to users by signing MySensors messages. </p>
<p>Signing support created by Patrick "Anticimex" Fallberg.</p>
<h1><a class="anchor" id="MySigninggrptoc"></a>
Table of contents</h1>
<p><a class="el" href="group___my_signinggrp_pub.html#MySigninggrphowuse">How to use this</a> <br  />
 <a class="el" href="group___my_signinggrp_pub.html#MySigningwhitelisting">Whitelisting and node revocation</a> <br  />
 <a class="el" href="group___my_signinggrp_pub.html#MySigninglimitations">Known limitations</a> <br  />
 <a class="el" href="group___my_signinggrp_pub.html#MySigningusecases">Typical use cases</a> <br  />
 <a class="el" href="group___my_signinggrp_pub.html#MySigningtechnical">The technical stuff</a> <br  />
 <a class="el" href="group___my_signinggrp_pub.html#MySigninggrpbackground">Background and concepts</a> <br  />
 <a class="el" href="group___my_signinggrp_pub.html#MySigninggrphow">How this is done</a> <br  />
 <a class="el" href="group___my_signinggrp_pub.html#MySigninggrpencryption">Why encryption is not part of this</a> <br  />
</p>
<h1><a class="anchor" id="MySigninggrphowuse"></a>
How to use this</h1>
<p>Before we begin with the details, I just want to emphasize that signing is completely optional and not enabled by default.</p>
<p>If you do want the additional security layer signing provides, you pick the backend of your choice in your sketch. Currently, two compatible backends are supported; MY_SIGNING_ATSHA204 (hardware backed) and MY_SIGNING_SOFT (software backed). There also exist a simplified variant (MY_SIGNING_SIMPLE_PASSWD) of the software backend which only require one setting to activate.</p>
<p>If you use hardware backed signing, then connect the device as follows: </p><div class="image">
<img src="MySigning/wiring.png" alt=""/>
</div>
 <dl class="section note"><dt>Note</dt><dd>The pull-up resistor is optional but recommended. </dd>
<dd>
If you change the default pin (A3) make sure you use a pin that supports input/output (ex. A6 &amp; A7 on a Pro Mini are input only pins).</dd></dl>
<p>To use signing, you need to perform three major steps which are described below.</p>
<p><b>Firstly</b>, you need to make sure to pick a backend to use. </p><div class="fragment"><div class="line"><span class="comment">//#define MY_SIGNING_SOFT</span></div>
<div class="line"><span class="comment">//#define MY_SIGNING_SIMPLE_PASSWD</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_ATSHA204</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p> Make sure to set the define before the inclusion of <a class="el" href="_my_sensors_8h.html" title="API declaration for MySensors.">MySensors.h</a>. It is ok to mix MY_SIGNING_SOFT and MY_SIGNING_ATSHA204 in a network. They are fully compatible. It is however not recommended to use MY_SIGNING_SOFT on nodes that are publicly accessible (more on that later).</p>
<p>If you use MY_SIGNING_SOFT or MY_SIGNING_ATSHA204 you also need to decide if the node (or gateway) in question require messages to be signed in addition to the ability to generate signatures for other nodes. This has to be set by at least one of the nodes in a "pair" or nobody will actually start calculating a signature for a message. Just set the flag MY_SIGNING_REQUEST_SIGNATURES and the node will inform the gateway that it expects the gateway to sign all messages sent to the node. Note that when set in a gateway, the gateway will require ALL nodes in the network to sign messages. If this behaviour is undesired, enable the flag MY_SIGNING_WEAK_SECURITY which will allow the gateway to only require signatures from nodes that in turn require signatures. It will also allow the gateway (and all nodes) to "downgrade" security by clearing the signing/whitelisting requirements (whitelisting is described later on in the <a class="el" href="group___my_signinggrp_pub.html#MySigningwhitelisting">Whitelisting and node revocation</a> section) in the EEPROM if a node presents itself as not having any security requirements. If MY_SIGNING_WEAK_SECURITY is not set, any node that has presented itself with signing/whitelisting requirements will be permanently marked as such by the receiver (typically the gateway). The only way then to reset/revert this requirement is to clear the EEPROM at the receiver (or disable MY_SIGNING_REQUEST_SIGNATURES, but the preference will be remembered if the request flag is re-enabled before EEPROM is cleared).<br  />
 If you want to have two nodes communicate securely directly with each other, the nodes that require signatures must send a presentation message to all nodes it expect signed messages from (only the gateway is informed automatically). See <a class="el" href="group___my_signinggrp.html#ga0c8b87323fc0b1b7f657721c8df2f563">signerPresentation()</a>.<br  />
 A node can have three "states" with respect to signing:</p><ol type="1">
<li>Node does not support signing in any way (neither MY_SIGNING_ATSHA204, MY_SIGNING_SOFT nor MY_SIGNING_SIMPLE_PASSWD is set)</li>
<li>Node does support signing but don't require messages sent to it to be signed (neither MY_SIGNING_REQUEST_SIGNATURES nor MY_SIGNING_SIMPLE_PASSWD is set)</li>
<li>Node does support signing and require messages sent to it to be signed (MY_SIGNING_SOFT or MY_SIGNING_ATSHA204 together with MY_SIGNING_REQUEST_SIGNATURES or MY_SIGNING_SIMPLE_PASSWD are set)</li>
</ol>
<p><b>Secondly</b>, you need to verify the configuration for the backend.<br  />
 For hardware backed signing it is the pin the device is connected to. In <a class="el" href="_my_config_8h.html" title="MySensors specific configuration flags.Set these in your sketch before including MySensors....">MyConfig.h</a> there are defaults which you might need to adjust to match your personal build. The setting is defined using <a class="el" href="group___signing_setting_grp_pub.html#ga36a091810aee650ffcf72f696e7bef8a">MY_SIGNING_ATSHA204_PIN</a>.<br  />
 If you use an official MySensors board (like the SenseBender GW) you do not need to set the pin, this is configured automatically by the Arduino board definition files.</p>
<p>Similar to picking your backend, this can also be set in your sketch: </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_ATSHA204</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_ATSHA204_PIN 4</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p> For the software backed signing backend, an unconnected analog pin is required on boards that does not provide a hardware based random generator unit to set a random seed for the pseudo-random generator. It is important that the pin is floating, or the output of the pseudo-random generator will be predictable, and thus compromise the signatures. The setting is defined using <a class="el" href="group___signing_setting_grp_pub.html#gad503356f7f7c23f7a5b16f079f47ce21">MY_SIGNING_SOFT_RANDOMSEED_PIN</a>. The same configuration possibilities exist as with the other configuration options.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>An example of a node that require signatures is available in SecureActuator.ino.</p>
<p><b>Thirdly</b>, if you use a signing backend and you don't use MY_SIGNING_SIMPLE_PASSWD, you need to personalize the node.</p>
<p><a class="anchor" id="personalization"></a>If you use the ATSHA204A (MY_SIGNING_ATSHA204), before any signing operations can be done, the device needs to be <em>personalized</em>. This can be a daunting process as it involves irreversibly writing configurations to the device, which cannot be undone. I have however tried to simplify the process as much as possibly by creating a helper-sketch specifically for this purpose in SecurityPersonalizer.ino Note that you also need to do personalization for MY_SIGNING_SOFT, but then the values are stored in EEPROM.</p>
<p>To personalize a ATSHA204A do the following procedure:</p><ol type="1">
<li>Enable GENERATE_KEYS_ATSHA204A<br  />
 This will lock the ATSHA204A and generate random keys for HMAC (signing) and AES (encryption). Copy the keys generated and replace the corresponding definitions under "User defined key data", specifically MY_HMAC_KEY and MY_AES_KEY.</li>
<li>Disable GENERATE_KEYS_ATSHA204A and enable PERSONALIZE_ATSHA204A<br  />
 This will store the HMAC key to the ATSHA204A and the AES key to EEPROM. It will also write a checksum of the personalization data in EEPROM to be able to detect if the data is altered.<br  />
 Personalization is now complete.</li>
</ol>
<p>To personalize for software signing do the following procedure:</p><ol type="1">
<li>Enable GENERATE_KEYS_SOFT<br  />
 This will generate random keys for HMAC (signing) and AES (encryption). Copy the keys generated and replace the corresponding definitions under "User defined key data", specifically MY_HMAC_KEY and MY_AES_KEY.</li>
<li>Disable GENERATE_KEYS_SOFT and enable PERSONALIZE_SOFT<br  />
 This will store the HMAC key and the AES key to EEPROM. It will also write a checksum of the personalization data in EEPROM to be able to detect if the data is altered.<br  />
 Personalization is now complete.</li>
</ol>
<p>If you want to use soft signing and you want to use whitelisting (the ability to revoke/ban compromised nodes in the network) and your target does not provide a unique device ID, you have to generate a unique serial and store it in EEPROM. This can be done by replacing PERSONALIZE_SOFT in step 2 above with PERSONALIZE_SOFT_RANDOM_SERIAL. See the output under "Hardware security peripherals" to determine if this is necessary.</p>
<p>When you have personalized your first device after step 2 above, you can run the same sketch on all devices in your network that needs to be personalized in a compatible manner. Pick PERSONALIZE_ATSHA204A or PERSONALIZE_SOFT as needed by the hardware. When the personalization has finished, you just program the sketch you plan to use (with the appropriate signing flags set).</p>
<p>If you are using a Raspberry PI-based gateway, personalizaion is done slightly differently:</p><ol type="1">
<li>Generate keys, execute <code>mysgw</code> with arguments<ul>
<li>To generate HMAC key<pre class="fragment">--gen-soft-hmac-key </pre></li>
<li>To generate AES key<pre class="fragment">--gen-aes-key </pre></li>
<li>To generate a soft serial number<pre class="fragment">--gen-soft-serial </pre></li>
</ul>
</li>
<li>Update the gateway config file with the generated keys/valeus<ul>
<li>For HMAC key<pre class="fragment">soft_hmac_key=&lt;DATA&gt; </pre></li>
<li>For AES key<pre class="fragment">aes_key=&lt;DATA&gt; </pre></li>
<li>For soft serial number<pre class="fragment">soft_serial_key=&lt;DATA&gt; </pre></li>
</ul>
</li>
</ol>
<p>You are now set and ready to use message signing in your network. As of now, the following restrictions will be applied to your nodes:</p><ul>
<li>If a node does require signing, any unsigned message sent to the node will be rejected. This also applies to the gateway.</li>
<li>Your radio communication quality is expected to work fine (if any NACK happen on a signing related message, it will fail, and enabling signing will put maximum strain on your RF link as maximum sized packets are transmitted in the network). See <a class="el" href="group___my_signing_troubleshootinggrp.html">Signing troubleshooting</a>.</li>
<li>All nodes and gateways in a network maintain a table where the signing preferences of all nodes are stored. This is also stored in EEPROM so if a node or gateway reboots, the other nodes does not have to retransmit a signing presentation to the node for the node to start expecting signed messages from other nodes.<br  />
</li>
<li>By default, the signing preferences are not "downgradeable". That is, any node that at any point in time has indicated a signing requirement will not be able to revert this requirement at the receiving end (except by manual erase of the EEPROM).<br  />
 If you for some reason need to be able to downgrade the security requirements, you can set MY_SIGNING_WEAK_SECURITY at the receiver to allow it to downgrade the security expectations of the node in question.<br  />
 You then need to reset your transmitting node, to force it to transmit updated signing preferences.</li>
</ul>
<h1><a class="anchor" id="MySigningwhitelisting"></a>
Whitelisting and node revocation</h1>
<p>Consider the situation when you have set up your secure topology. We use the remotely operated garage door as an example:</p><ul>
<li>You have a node inside your garage (considered physically inaccessible) that controls your garage door motor.<br  />
 This node requires signing since you do not want an unauthorized person sending it orders to open the door.</li>
<li>You have a keyfob node with a signing backend that uses the same PSK as your door opener node.</li>
</ul>
<p>In this setup, your keyfob can securely transmit messages to your door node since the keyfob will sign the messages it sends and the door node will verify that these were sent from a trusted node (since it used the correct PSK). If the keyfob does not sign the messages, the door node will not accept them. Optionally, your keyfob sends a signed message to your gateway (which require signatures) and the gateway in turn sends a signed message to your garage door.</p>
<p>One day your keyfob gets stolen or you lost it or it simply broke down.</p>
<p>You now end up with a problem; you need some way of telling your door node that the keyfob in question cannot be trusted any more. You could now repersonalize all your node to switch to a different PSK but this obviously is a hassle. How do you make sure that the "rogue" keyfob can be removed from the "trusted chain"?</p>
<p>The answer to this is whitelisting. You let your door node keep a whitelist of all nodes it trusts. If you stop trusting a particular node, you remove it from the nodes whitelist (by uploading a new sketch), and it will no longer be able to communicate signed messages to the door node.</p>
<p>In case you want to be able to "whitelist" trusted nodes (in order to be able to revoke them in case they are lost) you also need to take note of the serial number of the ATSHA device or the software value stored in EEPROM. This is unique for each device. The serial number is printed in a copy+paste friendly format by the personalizer for this purpose.<br  />
 The whitelist is stored on the node that require signatures. When a received message is verified, the serial of the sender is looked up in a list stored on the receiving node, and the corresponding serial stored in the list for that sender is then included in the signature verification process. The list is stored as the value of the flag that enables whitelisting, MY_SIGNING_NODE_WHITELISTING.<br  />
</p>
<p>Whitelisting is achieved by 'salting' the signature with some node-unique information known to the receiver. In the case of MY_SIGNING_ATSHA204 this is the unique serial number programmed into the circuit. This unique number is never transmitted over the air in clear text, so Eve will not be able to figure out a "trusted" serial by snooping on the traffic.<br  />
 Instead the value is hashed together with the senders NodeId into the HMAC signature to produce the final signature. The receiver will then take the originating NodeId of the signed message and do the corresponding calculation with the serial it has stored in it's whitelist if it finds a matching entry in it's whitelist.</p>
<p>Whitelisting is an optional alternative because it adds some code and configuration options which might not be desirable for every user. So if you want the ability to use whitelists, you need to enable MY_SIGNING_NODE_WHITELISTING. You need to remember that the gateway will remember if a node has presented it with a whitelisting requirement as described above, if you at some point decide to remove the whitelist requirement.<br  />
 The whitelist is provided as value of the flag that enable it as follows (example is a node that require signing as well): </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_ATSHA204</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_NODE_WHITELISTING {{.nodeId = GATEWAY_ADDRESS,.serial = {0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01}},{.nodeId = 2,.serial = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09}}}</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p> In this example, there are two nodes in the whitelist; the gateway, and a separate node that communicates directly with this node (with signed messages). You do not need to do anything special for the sending nodes, apart from making sure they support signing.</p>
<p>The "soft" backend of course also support whitelisting. Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_NODE_WHITELISTING {{.nodeId = GATEWAY_ADDRESS,.serial = {0x09,0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01}},{.nodeId = 2,.serial = {0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09}}}</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>For a node that should transmit whitelisted messages but not receive whitelisted messages, you do not need any special configurations: </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7</span></div>
</div><!-- fragment --><p> Remember that you always need to select a signing backend for all nodes that communicate to a node that require whitelisting. Also, note that a node that use whitelisting will not accept messages from nodes that are not present in it's whitelist. And you have to personalize all nodes that use signing with a common HMAC key but different serial numbers (MY_SIGNING_ATSHA204 always has unique serials).</p>
<h1><a class="anchor" id="MySigninglimitations"></a>
Known limitations</h1>
<p>Due to the limiting factor of our cheapest Arduino nodes, the use of diversified keys is not implemented. That mean that all nodes in your network share the same PSK (at least the ones that are supposed to exchange signed data). It is important to understand the implications of this, and that is covered in the "Typical use cases" chapter below.<br  />
 Most importantly, if you use MY_SIGNING_SOFT your PSK will be stored in EEPROM and will therefore be accessible by anyone with physical access to your node. Therefore it is <b>NOT</b> recommended to use MY_SIGNING_SOFT on nodes that are placed in a public place or worn on on your person (like a keyfob).<br  />
 Also be reminded that the strength of the signature is inversely proportional to the size of the message. The larger the message, the weaker the signature.</p>
<h1><a class="anchor" id="MySigningusecases"></a>
Typical use cases</h1>
<p>"Securely located" in this context mean a node which is not physically publicly accessible. Typically at least your gateway.<br  />
 "Public" in this context mean a node that is located outside your "trusted environment". This includes sensors located outdoors, keyfobs etc.</p>
<h2><a class="anchor" id="MySigninglock"></a>
Securely located lock</h2>
<p>You have a securely located gateway and a lock somewhere inside your "trusted environment" (e.g. inside your house door, the door to your dungeon or similar).<br  />
 You need to make your node require signed messages but you do not necessarily need to make your gateway require signed messages (unless you are concerned that someone might spoof the lock status of your lock).<br  />
 Configuration example for the secure lock node:<br  />
 </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_ATSHA204</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p> If you do also want your gateway to require signatures from your lock you just enable the same (or similar if using software signing) settings in the gateway.</p>
<h2><a class="anchor" id="MySigningpatio"></a>
Patio motion sensor</h2>
<p>Your gateway is securely located inside your house, but your motion sensor is located outside your house. You have for some reason elected that this node should sign the messages it send to your gateway. You should lock the data (PSK) in this node then, because if someone were to steal your patio motion sensor, they could rewrite the firmware and spoof your gateway to use it to transmit a correctly signed message to your secure lock inside your house. But if you revoke your gateway (and lock) PSK the outside sensor cannot be used for this anymore. Nor can it be changed in order to do it in the future. You can also use whitelisting to revoke your lost node.<br  />
 This is an unlikely use case because there really is no reason to sign sensor values. If you for some reason want to obfuscate sensor data, encryption is a better alternative.<br  />
 Configuration example for a motion sensor:<br  />
 </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>The gateway needs to be configured with a whitelist (and it has to have an entry for all nodes that send and/or require signed messages):<br  />
 </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_NODE_WHITELISTING {{.nodeId = MOTION_SENSOR_ID,.serial = {0x12,0x34,0x56,0x78,0x90,0x12,0x34,0x56,0x78}}}</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="MySigningkeyfob"></a>
Keyfob for garage door opener</h2>
<p>Perhaps the most typical usecase for signed messages. Your keyfob should be totally locked down. If the garage door opener is secured (and it should be) it can be unlocked. That way, if you loose your keyfob, you can revoke the PSK in both the opener and your gateway, thus rendering the keyfob useless without having to replace your nodes. You can also use whitelisting to revoke your lost keyfob.<br  />
 Configuration example for the keyfob (keyfob will only transmit to another node and not receive anything):<br  />
 </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_ATSHA204</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><p>Configuration example for the door controller node (should require signing from anyone who wants to control it):<br  />
 </p><div class="fragment"><div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_SOFT_RANDOMSEED_PIN 7</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_REQUEST_SIGNATURES</span></div>
<div class="line"><span class="preprocessor">#define MY_SIGNING_NODE_WHITELISTING {{.nodeId = GATEWAY_ADDRESS,.serial = {0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88}},{.nodeId = KEYFOB_ID,.serial = {&lt;FROM ATSHA ON KEYFOB&gt;}}}</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_my_sensors_8h.html">MySensors.h</a>&gt;</span></div>
<div class="line">...</div>
</div><!-- fragment --><h2><a class="anchor" id="MySigningsketches"></a>
Relevant sketches</h2>
<ul>
<li>SecureActuator.ino</li>
<li>SecurityPersonalizer.ino</li>
</ul>
<h1><a class="anchor" id="MySigningtechnical"></a>
The technical stuff</h1>
<p>The following sequence diagram illustrate how messages are passed in a MySensors network with respect to signing: </p><div class="image">
<img src="MySigning/signingsequence.png" alt=""/>
</div>
<p>None of this activity is “visible” to you (as the sensor sketch implementor). All you need to do is to set your preferences in your sketch and personalize accordingly. That is enough to enable protection from both Eve and Mallory in your network although if you do not also enable encryption, Eve can eavesdrop, but not do anything about, your messages (except possibly preventing them from arriving).</p>
<p>How are the messages actually affected by the signing?<br  />
 The following illustration shows what part of the message is signed, and where the signature is stored: </p><div class="image">
<img src="MySigning/signingillustrated1.png" alt=""/>
</div>
<p>The first byte of the header is not covered by the signature, because in the network, this byte is used to track hops in the network and therefore might change if the message is passing a relay node. So it cannot be part of the signature, or the signature would be invalid when it arrives to its destination. The signature also carries a byte with a signing identifier to prevent false results from accidental mixing of incompatible signing backends in the network. Thus, the maximum size for a payload is 29-7 bytes. Larger payloads are not possible to sign at the moment. Another thing to consider is that the strength of the signature is inversely proportional to the payload size.</p>
<p>As for the software backend, it turns out that the ATSHA does not do “vanilla” HMAC processing. Fortunately, Atmel has documented exactly how the circuit processes the data and hashes thus making it possible to generate signatures that are identical to signatures generated by the circuit.</p>
<p>The signatures are calculates in the following way: </p><div class="image">
<img src="MySigning/signingillustrated2.png" alt=""/>
</div>
<p>Exactly how this is done can be reviewed in the source for the software backend (MySigningAtsha204Soft.cpp) and the ATSHA204A <a href="http://www.atmel.com/Images/Atmel-8885-CryptoAuth-ATSHA204A-Datasheet.pdf">datasheet </a>. In the MySensors protocol, the following internal messagetypes handles signature requirements and nonce requests:<br  />
 <a class="el" href="group___my_messagegrp.html#gga5636ada210e2435e058d917640d32732a33ca9404b08a325f461d1ff37bd49245">I_SIGNING_PRESENTATION</a> <br  />
 <a class="el" href="group___my_messagegrp.html#gga5636ada210e2435e058d917640d32732a7b22c33d6e0c84ca21f8859cb4c4309d">I_NONCE_REQUEST</a> <br  />
 <a class="el" href="group___my_messagegrp.html#gga5636ada210e2435e058d917640d32732a9f3e22de05e07ef93d35ecb69798fcdb">I_NONCE_RESPONSE</a> <br  />
</p>
<p>Also, the version field in the header has been reduced from 3 to 2 bits in order to fit a single bit to indicate that a message is signed.</p>
<h1><a class="anchor" id="MySigninggrpbackground"></a>
Background and concepts</h1>
<p>Suppose two participants, Alice and Bob, wants to exchange a message. Alice sends a message to Bob. In MySensors “language” Alice could be a gateway and Bob an actuator (light switch, electronic lock, etc). But to be generic, we will substitute the term “gateway” with Alice and a “node” with Bob (although the reverse relationship is also supported).</p>
<p>Alice sends a message to Bob. This message can be heard by anyone who wants to listen (and also by anyone that is within “hearing” distance). Normally, this is perhaps not a big issue. Nothing Alice says to Bob may be secret or sensitive in any way. However, sometimes (or perhaps always) Bob want to be sure that the message Bob receives actually came from Alice. In cryptography, this is known as <em>authenticity</em>. Bob needs some way of determining that the message is authentic from Alice, when Bob receives it. This prevents an eavesdropper, Eve, to trick Bob into thinking it was Alice that sent a message Eve in fact transmitted. Bob also needs to know how to determine if the message has been repeated. Eve could record a message sent by Alice that Bob accepted and then send the same message again. Eve could also in some way prevent Bob from receiving the message and delay it in order to permit the message to arrive to Bob at a time Eve chooses, instead of Alice. Such an attack is known as a <b>replay attack</b>.<br  />
 <em>Authenticity</em> permits Bob to determine if Alice is the true sender of a message. </p><div class="image">
<img src="MySigning/alicenfriends.png" alt=""/>
</div>
<p>It can also be interesting for Bob to know that the message Alice sent has not been tampered with in any way. This is the <em>integrity</em> of the message. We now introduce Mallory, who could be intercepting the communication between Alice and Bob and replace some parts of the message but keeping the parts that authenticate the message. That way, Bob still trusts Alice to be the source, but the contents of the message was not the content Alice sent. Bob needs to be able to determine that the contents of the message was not altered after Alice sent it.<br  />
 Mallory would in this case be a <b>man-in-the-middle</b> attacker.<br  />
 <em>Integrity</em> permits Bob to verify that the messages received from Alice has not been tampered with.<br  />
 This is achieved by adding a <em>signature</em> to the message, which Bob can inspect to validate that Alice is the author. </p><div class="image">
<img src="MySigning/alicenfriends2.png" alt=""/>
</div>
<p>The signing scheme used, needs to address both these attack scenarios. Neither Eve nor Mallory must be permitted to interfere with the message exchange between Alice and Bob.</p>
<p>The key challenge to implementing a secure signing scheme is to ensure that every signature is different, even if the message is not. If not, <b>replay attacks</b> would be very hard to prevent.<br  />
 One way of doing this is to increment some counter on the sender side and include it in the signature. This is however predictable.<br  />
 A better option would be to introduce a random number to the signature. That way, it is impossible to predict what the signature will be. The problem is, that also makes it impossible for the receiver (Bob) to verify that the signature is valid.<br  />
 A solution to this is to let Bob generate the random number, keep it in memory and send it to Alice. Alice can then use the random number in the signature calculation and send the signed message back to Bob who can validate the signature with the random number used. This random number is in cryptography known as a <a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a> or <a href="https://en.wikipedia.org/wiki/Salt_%28cryptography%29">salt</a>.</p>
<p>However, Mallory might be eavesdropping on the communication and snoop up the nonce in order to generate a new valid signature for a different message. To counter this, both Alice and Bob keep a secret that only they know. This secret is never transmitted over the air, nor is it revealed to anybody. This secret is known as a <a href="https://en.wikipedia.org/wiki/Pre-shared_key">pre-shared key</a> (PSK).</p>
<p>If Eve or Mallory are really sophisticated, he/she might use a <b>delayed replay attack</b>. This can be done by allowing Bob to transmit a nonce to Alice. But when Alice transmits the uniquely signed message, Mallory prevents Bob from receiving it, to a point when Mallory decides Bob should receive it. An example of such an attack is described <a href="http://spencerwhyte.blogspot.se/2014/03/delay-attack-jam-intercept-and-replay.html">here</a>.<br  />
 This needs to be addressed as well, and one way of doing this is to have Bob keep track of time between a transmitted nonce and a signed message to verify. If Bob is asked for a nonce, Bob knows that a signed message is going to arrive “soon”. Bob can then decide that if the signed message does not arrive within a predefined timeframe, Bob throws away the generated nonce and thus makes it impossible to verify the message if it arrives late.</p>
<p>The flow can be described like this: </p><div class="image">
<img src="MySigning/alicenbob.png" alt=""/>
</div>
<p> The benefits for MySensors to support this are obvious. Nobody wants others to be able to control or manipulate any actuators in their home.</p>
<h1><a class="anchor" id="MySigninggrphow"></a>
How this is done</h1>
<p>There exist many forms of message signature solutions to combat Eve and Mallory.<br  />
 Most of these solutions are quite complex in term of computations, so I elected to use an algorithm that an external circuit is able to process. This has the added benefit of protecting any keys and intermediate data used for calculating the signature so that even if someone were to actually steal a sensor and disassembled it, they would not be able to extract the keys and other information from the device.<br  />
 A common scheme for message signing (authenticity and integrity) is implemented using <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC</a> which in combination with a strong <a href="http://en.wikipedia.org/wiki/Hash_function">hash function</a> provides a very strong level of protection.<br  />
 The <a href="http://www.atmel.com/devices/ATSHA204A.aspx">Atmel ATSHA204A</a> is a low-cost, low-voltage/current circuit that provides HMAC calculation capabilities with SHA256 hashing which is a (currently) virtually unbreakable combination. If SHA256 were to be hacked, a certain <a href="http://en.wikipedia.org/wiki/Bitcoin">cryptocurrency</a> would immediately be rendered worthless.<br  />
 The ATSHA device also contain a random number generator (RNG) which enables the generation of a good nonce, as in, <em>non-predictable</em>.<br  />
 As I acknowledge that some might not want to use an additional external circuit, I have also implemented a software version of the ATSHA device, capable of generating the same signatures as the ATSHA device does. Because it is pure-software however, it does not provide as good nonces (it uses the <a href="http://arduino.cc/en/reference/random">Arduino pseudo-random generator</a>) and the HMAC key is stored in SW and is therefore readable if the memory is dumped. It also naturally claims more flash space due to the more complex software. But for indoor sensors/actuators this might be good enough for most people.</p>
<h1><a class="anchor" id="MySigninggrpencryption"></a>
Why encryption is not part of this</h1>
<p>Well, some could be uncomfortable with somebody being able to snoop temperatures, motion or the state changes of locks in the environment. Signing does <b>not</b> address these issues. Encryption is needed to prevent this.<br  />
 It is my personal standpoint that encryption should not be part of the MySensors “protocol”. The reason is that a gateway and a node does not really care about messages being readable or not by “others”. It makes more sense that such guarantees are provided by the underlying transmission layer (RF solution in this case). It is the information transmitted over the air that needs to be secret (if user so desires). The “trust” level on the other hand needs to go all the way into the sketches (who might have different requirements of trust depending on the message participant), and for this reason, it is more important (and less complicated) to ensure authenticity and <em>integrity</em> at protocol-level as message contents is still readable throughout the protocol stack. But as soon as the message leaves the “stack” it can be scramble into “garbage” when transmitted over the air and then reassembled by a receiving node before being fed in “the clear” up the stack at the receiving end.</p>
<p>There are methods and possibilities to provide encryption also in software, but if this is done, it is my recommendation that this is done after integrity- and authentication information has been provided to the message (if this is desired). Integrity and authentication is of course not mandatory and some might be happy with only having encryption to cover their need for security. I, however, have only focused on <em>integrity</em> and <em>authenticity</em> while at the same time keeping the current message routing mechanisms intact and therefore leave the matter of <em>secrecy</em> to be implemented in the “physical” transport layer. With the <em>integrity</em> and <em>authenticity</em> handled in the protocol it ought to be enough for a simple encryption (nonce-less AES with a PSK for instance) on the message as it is sent to the RF backend. Atmel does provide such circuits as well but I have not investigated the matter further as it given the current size of the ethernet gateway sketch is close to the size limit on an Arduino Nano, so it will be difficult to fit this into some existing gateway designs.<br  />
 Also it is worth to consider that the state of a lock can just as readily be determined by simply looking at the door in question or attempting to open it, so obfuscating this information will not necessarily deter an attacker in any way.<br  />
 Nevertheless, I do acknowledge that people find the fact that all information is sent “in the clear” even if it require some technical effort for an intruder to obtain and inspect this information. So I do encourage the use of encrypting transport layers.<br  />
 This is however not covered by this implementation.<br  />
 This might change in the future as more powerful platforms emerge which permit more complex security schemes and better hardware acceleration. </p>
</div><!-- contents -->
<div class="ttc" id="a_my_sensors_8h_html"><div class="ttname"><a href="_my_sensors_8h.html">MySensors.h</a></div><div class="ttdoc">API declaration for MySensors.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
